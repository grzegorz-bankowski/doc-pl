<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 22583751fbfdaa3eaa41aeb6470d1343f5cb2c78 Maintainer: sobak Status: ready -->
<sect1 xml:id="language.types.array">
 <title>Tablice</title>

 <para>
  Tablica (<type>array</type>) w PHP to tak naprawdę posortowana mapa. Mapa to typ, który
  przepisuje <emphasis>wartość</emphasis> do <emphasis>kluczy</emphasis> (klucze są też nazywane indeksami). Ten typ
  jest zoptymalizowany dla kilku różnych przypadków; może być traktowany jako tablica,
  lista (wektor), hash table (implementację mapy), słownik,
  kolekcja, stos kolejka i prawdopodobnie więcej. Jako że wartościami tablicy
  mogą być inne tablice, możliwe jest tworzenie drzew i wielowymiarowych
  tablic.
 </para>

 <para>
  Wyjaśnienie tych typów danych wykracza poza zakres tego podręcznika, ale
  dla każdego z nich podano przynajmniej jeden przykład. Aby dowiedzieć się więcej,
  szukaj uznanej literatury dotyczącej tego rozbudowanego tematu.
 </para>
   
 <sect2 xml:id="language.types.array.syntax">
  <title>Składnia</title>
  
  <sect3 xml:id="language.types.array.syntax.array-func">
   <title>Określanie przy użyciu <function>array</function></title>

   <para>
    Tablica może być stworzona używając konstrukcji języka <function>array</function>.
    Przyjmuje ona dowolną liczbę par
    <literal><replaceable>klucz</replaceable> =&gt; <replaceable>wartość</replaceable></literal>
    oddzielonych przecinkami jako argumenty.
   </para>

   <synopsis>
array(
    <optional><replaceable>klucz</replaceable>  =&gt; </optional><replaceable>wartość</replaceable>,
    <optional><replaceable>klucz2</replaceable> =&gt; </optional><replaceable>wartość2</replaceable>,
    <optional><replaceable>klucz3</replaceable> =&gt; </optional><replaceable>wartość3</replaceable>,
    ...
)</synopsis>
   <!-- Do not fix the whitespace for the synopsis end element. A limitation of PhD prevents proper trimming -->

   <para>
    Przecinek po ostatnim elemencie tablicy jest opcjonalny i można go pominąć. Pomija się go zwykle
    dla tablic definiowanych w jednej linii, np. <literal>array(1, 2)</literal> zamiast
    <literal>array(1, 2, )</literal>. Dla tablic deklarowanych w wielu liniach użycie końcowego przecinka
    jest powszechne, bo pozwala na łatwiejsze dodawanie nowych elementów na końcu tablicy.
   </para>

   <note>
    <para>
     Istnieje skrócona składnia tablic, która zamienia
     <literal>array()</literal> na <literal>[]</literal>.
    </para>
   </note>

   <example>
    <title>Prosta tablica</title>
    <programlisting role="php">
<![CDATA[
<?php
$tablica = array(
    "foo" => "bar",
    "bar" => "foo",
);

// Używając skróconej składni
$tablica = [
    "foo" => "bar",
    "bar" => "foo",
];
?>
]]>
    </programlisting>
   </example>
   
   <para>
    <replaceable>Klucz</replaceable> może być liczbą całkowitą (<type>int</type>)
    lub ciągiem znaków (<type>string</type>). <replaceable>Wartość</replaceable> może być
    dowolnego typu.
   </para>
   
   <para xml:id="language.types.array.key-casts">
    Ponadto wystąpią następujące rzutowania typu <replaceable>klucza</replaceable>:
    <itemizedlist>
     <listitem>
      <simpara>
       Ciągi znaków (<type>string</type>) zawierające poprawną liczbę w systemie dziesiętnym będą zrzutowane na
       liczbę całkowitą (<type>int</type>), chyba, że liczba jest poprzedzona znakiem <literal>+</literal>. Na przykład klucz <literal>"8"</literal> będzie
       tak naprawdę zachowany jako <literal>8</literal>. Z drugiej strony <literal>"08"</literal> nie będzie
       zrzutowany, ponieważ nie jest poprawną liczbą w systemie dziesiętnym.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Liczby zmiennoprzecinkowe (<type>float</type>) także są rzutowane na liczby całkowite, co oznacza, że
       część ułamkowa jest ucinana. Na przykład klucz <literal>8.7</literal> zostanie tak naprawdę
       zachowany jako <literal>8</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Wartości logiczne (<type>bool</type>) też są rzutowane na liczby całkowite, tj. klucz
       &true; zostanie tak naprawdę zapisany jako <literal>1</literal>
       a klucz &false; jako <literal>0</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <type>Null</type> zostanie zrzutowany na pusty ciąg znaków, a więc klucz
       <literal>null</literal> zostanie tak naprawdę zapisany jako <literal>""</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Tablice i obiekty <emphasis>nie mogą</emphasis> być używane jako klucze.
       W takim razie zostanie pokazanie ostrzeżenie: <literal>Illegal offset type</literal>.
      </simpara>
     </listitem>
    </itemizedlist>
   </para>
   
   <para>
    Jeżeli wiele elementów tablicy używa tego samego klucza, to tylko ostatni z nich
    zostanie użyty, bo wszystkie wcześniejsze zostaną nadpisane.
   </para>
   
   <example>
    <title>Przykład rzutowania typów i nadpisywania</title>
    <programlisting role="php">
<![CDATA[
<?php
$tablica = array(
    1    => "a",
    "1"  => "b",
    1.5  => "c",
    true => "d",
);
var_dump($tablica);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(1) {
  [1]=>
  string(1) "d"
}
]]>
    </screen>
    <para>
     Jako że wszystkie klucze w powyższym przykładzie są rzutowane do <literal>1</literal> wartość będzie nadpisywana
     przy każdym nowym elemencie, a ostatnia przypisana wartość <literal>"d"</literal> będzie jedną użytą.
    </para>
   </example>  
   
   <para>
    Tablice PHP mogą zawierać klucze o typach <type>int</type> oraz <type>string</type> jednocześnie,
    jako że PHP nie ma rozróżnienia między tablicami indeksowanymi i asocjacyjnymi.
   </para>
   
   <example>
    <title>Wymieszane klucze <type>int</type> i <type>string</type></title>
    <programlisting role="php">
<![CDATA[
<?php
$tablica = array(
    "foo" => "bar",
    "bar" => "foo",
    100   => -100,
    -100  => 100,
);
var_dump($tablica);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(4) {
  ["foo"]=>
  string(3) "bar"
  ["bar"]=>
  string(3) "foo"
  [100]=>
  int(-100)
  [-100]=>
  int(100)
}
]]>
    </screen>
   </example>
   
   <para>
    <replaceable>Klucz</replaceable> jest opcjonalny. Jeśli nie jest określony, PHP zwiększy
    o jeden największy ostatnio użyty klucz numeryczny.
   </para>
   
   <example>
    <title>Indeksowane tablice bez klucza</title>
    <programlisting role="php">
<![CDATA[
<?php
$tablica = array("foo", "bar", "hello", "world");
var_dump($tablica);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(4) {
  [0]=>
  string(3) "foo"
  [1]=>
  string(3) "bar"
  [2]=>
  string(5) "hello"
  [3]=>
  string(5) "world"
}
]]>
    </screen>
   </example>
   
   <para>
    Można określić klucz tylko dla niektórych elementów i pominąć go dla innych:
   </para>
   
   <example>
    <title>Klucz nie dla wszystkich elementów</title>
    <programlisting role="php">
<![CDATA[
<?php
$tablica = array(
         "a",
         "b",
    6 => "c",
         "d",
);
var_dump($tablica);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(4) {
  [0]=>
  string(1) "a"
  [1]=>
  string(1) "b"
  [6]=>
  string(1) "c"
  [7]=>
  string(1) "d"
}
]]>
    </screen>
    <para>
     Jak widać ostatnia wartość <literal>"d"</literal> została przypisana do klucza
     <literal>7</literal>. Stało się tak, ponieważ największym kluczem liczbowym użytym wcześniej
     był <literal>6</literal>.
    </para>
   </example>

   <example>
    <title>Złożony przykład rzutowania typów i nadpisywania</title>
    <para>
     Ten przykład zawiera wszystkie odmiany rzutowania typów kluczy i nadpisywania
     elementów.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$tablica = array(
    1    => 'a',
    '1'  => 'b', // wartość "a" będzie nadpisana przez "b"
    1.5  => 'c', // wartość "b" będzie nadpisana przez "c"
    -1 => 'd',
    '01'  => 'e', // jako że nie jest to numeryczny ciąg znaków, to NIE nadpisze on klucza 1
    '1.5' => 'f', // jako że nie jest to numeryczny ciąg znaków, to NIE nadpisze on klucza 1
    true => 'g', // wartość "c" zostanie nadpisana przez "g"
    false => 'h',
    '' => 'i',
    null => 'j', // wartość "i" zostanie nadpisana przez "j"
    'k', // wartość "k" ma przypisany klucz 2. Dzieje się tak, bo największy klucz numeryczny użyty wcześniej to 1
    2 => 'l', // wartość "k" zostanie nadpisana przez "l"
);

var_dump($tablica);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(7) {
  [1]=>
  string(1) "g"
  [-1]=>
  string(1) "d"
  ["01"]=>
  string(1) "e"
  ["1.5"]=>
  string(1) "f"
  [0]=>
  string(1) "h"
  [""]=>
  string(1) "j"
  [2]=>
  string(1) "l"
}
]]>
    </screen>
   </example>

   <example>
    <title>Przykład indeksów ujemnych</title>
    <simpara>
     Jeśli przypisany zostanie ujemny klucz <literal>n</literal> PHP przypisze następny
     klucz jako <literal>n+1</literal>.
    </simpara>
    <programlisting role="php">
     <![CDATA[
<?php
$tablica = [];

$tablica[-5] = 1;
$tablica[] = 2;

var_dump($tablica);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
     <![CDATA[
array(2) {
  [-5]=>
  int(1)
  [-4]=>
  int(2)
}
]]>
    </screen>

    <warning>
     <simpara>
      Przed PHP 8.3.0 przypisanie ujemnego klucza <literal>n</literal> przypisałoby
      następnie klucz <literal>0</literal>, więc poprzedni przykład
      wyświetliłby::
     </simpara>
     <informalexample>
      <screen>
<![CDATA[
array(2) {
  [-5]=>
  int(1)
  [0]=>
  int(2)
}
]]>
      </screen>
     </informalexample>
    </warning>
   </example>
  </sect3>
  
  <sect3 xml:id="language.types.array.syntax.accessing">
   <title>Dostęp do elementów tablicy przy użyciu nawiasów kwadratowych</title>
   
   <para>
    Dostęp do elementów tablicy można uzyskać używając składni <literal>tablica[klucz]</literal>>.
   </para>
   
   <example>
    <title>Dostęp do elementów tablicy</title>
    <programlisting role="php">
<![CDATA[
<?php
$tablica = array(
    "foo" => "bar",
    42    => 24,
    "wielo" => array(
         "wymiarowa" => array(
             "tablica" => "foo"
         )
    )
);

var_dump($tablica["foo"]);
var_dump($tablica[42]);
var_dump($tablica["wielo"]["wymiarowa"]["tablica"]);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
string(3) "bar"
int(24)
string(3) "foo"
]]>
    </screen>
   </example>
   
   <note>
    <para>
     Przed PHP 8.0.0 można było wymiennie używać nawiasów kwadratowych i klamrowych
     dla uzyskania dostępu do elementów tablicy (np. <literal>$tablica[42]</literal> i <literal>$tablica{42}</literal>
     działałyby tak samo).
     Składnia z nawiasami klamrowymi została uznana za przestarzałą od PHP 7.4.0 a od PHP 8.0.0 nie jest już obsługiwana.
    </para>
   </note>

   <example>
    <title>Dereferencja tablic</title>
    <programlisting role="php">
<![CDATA[
<?php
function pobierzTablice() {
    return array(1, 2, 3);
}

$drugiElement = pobierzTablice()[1];
?>
]]>
    </programlisting>
   </example>
   
   <note>
    <para>
      Próba dostępu do klucza tablicy, który nie został zdefiniowany działa
      tak samo jak dostęp do dowolnej innej niezdefiniowanej zmiennej:
      zostanie pokazane ostrzeżenie <constant>E_WARNING</constant>
      (lub <constant>E_NOTICE</constant> przed PHP 8.0.0),
      a wynikiem będzie &null;.
    </para>
   </note>
   <note>
    <para>
     Dereferencja wartości skalarnej z tablicy, która nie jest ciągiem znaków,
     skutkuje typem &null;. Przed PHP 7.4.0 nie powodowało to wiadomości błędu.
     Od PHP 7.4.0 powoduje to komunikat <constant>E_NOTICE</constant>,
     a od PHP 8.0.0 ostrzeżenie <constant>E_WARNING</constant>.
    </para>
   </note>
  </sect3>
  
  <sect3 xml:id="language.types.array.syntax.modifying">
   <title>Tworzenie lub modyfikacja wartości używając nawiasów kwadratowych</title>

   <para>
    Istniejące tablice mogą być modyfikowane, jeśli wprost ustawimy wartości
    w nich zawarte.
   </para>

   <para>
    Można to uzyskać przez przypisanie wartości do tablicy, określając
    klucz w nawiasach kwadratowych. Klucz można też pominąć, czyli użyć pustej pary
    nawiasów kwadratowych (<literal>[]</literal>).
   </para>
   
   <synopsis>
$tablica[<replaceable>klucz</replaceable>] = <replaceable>wartość</replaceable>;
$tablica[] = <replaceable>wartość</replaceable>;
// <replaceable>klucz</replaceable> może być typu <type>int</type> lub <type>string</type>
// <replaceable>wartość</replaceable> może być dowolnego typu</synopsis>
   
   <para>
    Jeżeli zmienna <varname>tablica</varname> nie istnieje lub jest ustawiona na &null; lub &false; to zostanie utworzona, więc
    jest to też alternatywny sposób tworzenia tablicy. Ta praktyka
    nie jest jednak zalecana, ponieważ jeśli <varname>$tablica</varname> zawiera już
    jakąś wartość (np. <type>string</type>) to ta wartość w niej pozostanie a <literal>[]</literal> może zostać zinterpretowane
    jako <link linkend="language.types.string.substr">operator dostępu do
    ciągu znaków</link>. Zawsze lepiej jest utworzyć zmienną używając bezpośredniego
    przypisania.
   </para>
   <note>
    <simpara>
     Od PHP 7.1.0 użycie pustego operatora klucza (<literal>[]</literal>) na ciągu znaków powoduje błąd
     krytyczny. Wcześniej ciąg znaków był po cichu konwertowany na tablicę bez zgłoszenia żadnego błędu.
    </simpara>
   </note>
   <note>
    <simpara>
     Od PHP 8.1.0 tworzenie nowej tablicy z wartości &false; jest przestarzałe.
     Tworzenie nowej tablicy z &null; i niezdefiniowanych wartości wciąż jest dozwolone.
    </simpara>
   </note>

   <para>
    Aby zmienić określoną
    wartość przypisz wartość temu elementowi używając jej klucza. Aby usunąć
    parę klucz/wartość, użyj na niej funkcji <function>unset</function>.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$tablica = array(5 => 1, 12 => 2);

$tablica[] = 56;    // Równoznaczne z użyciem $tablica[13] = 56;
                    // w tym miejscu skryptu

$tablica["x"] = 42; // Dodaje nowy element do
                    // tablicy z kluczem "x"
                
unset($tablica[5]); // Usuwa element z tablicy

unset($tablica);    // Usuwa całą tablicę
?>
]]> 
    </programlisting>
   </informalexample>

   <note>
    <para>
     Jak wspomniano wyżej, jeśli klucz nie jest określony, to używany jest największy z istniejących
     kluczy numerycznych, a nowym kluczem będzie ta maksymalna wartość
     plus 1 (ale nie mniej niż 0). Jeśli nie istnieje jeszcze żaden indeks numeryczny, to kluczem
     będzie <literal>0</literal> (zero). 
    </para>

    <para>
     Zwróć uwagę, że maksymalny klucz używany do tego <emphasis>nie musi
     obecnie istnieć w tablicy</emphasis>. Musiał on tylko istnieć
     w tablicy w chwili kiedy tablica była
     ostatnio przeindeksowana. Pokazuje to poniższy przykład:
    </para>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Stwórz prostą tablicę
$tablica = array(1, 2, 3, 4, 5);
print_r($tablica);

// Teraz skasuj każdy element, ale nie kasuj samej tablicy:
foreach ($tablica as $i => $wartosc) {
    unset($tablica[$i]);
}
print_r($tablica);

// Przypisz element (zauważ, że nowym kluczem jest 5 a nie 0).
$tablica[] = 6;
print_r($tablica);

// Przeindeksuj tablicę:
$tablica = array_values($tablica);
$tablica[] = 7;
print_r($tablica);
?>
]]> 
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
     </screen>
    </informalexample>

   </note>

  </sect3>

  <sect3 xml:id="language.types.array.syntax.destructuring">
   <title>Destrukturyzacja tablicy</title>

   <para>
    Tablice można destrukturyzować używając <literal>[]</literal> (od PHP 7.1.0) lub
    konstrukcji językowej <function>list</function>. Te
    konstrukcje mogą być użyte do destrukturyzacji tablicy do zmiennych.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$tablica_zrodlowa = ['foo', 'bar', 'baz'];

[$foo, $bar, $baz] = $tablica_zrodlowa;

echo $foo;    // wyświetla "foo"
echo $bar;    // wyświetla "bar"
echo $baz;    // wyświetla "baz"
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Destrukturyzacja tablicy może być użyta w &foreach; aby zdestrukturyzować
    wielowymiarową tablicę w trakcie iterowania po niej.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$tablica_zrodlowa = [
    [1, 'John'],
    [2, 'Jane'],
];

foreach ($tablica_zrodlowa as [$id, $imie]) {
    // logika używająca zmiennych $id i $imie
}
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Elementy tablicy będą zignorowane jeśli nie została podana zmienna. Destrukturyzacja
    tablicy zawsze zaczyna się od indeksu <literal>0</literal>.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$tablica_zrodlowa = ['foo', 'bar', 'baz'];

// Assign the element at index 2 to the variable $baz
[, , $baz] = $tablica_zrodlowa;

echo $baz;    // wyświetla "baz"
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Od PHP 7.1.0 tablice asocjacyjne też mogą być destrukturyzowane. Pozwala
    to też na prostszy wybór właściwego elementu z tablic indeksowanych numerycznie,
    ponieważ indeks można podać wprost.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$tablica_zrodlowa = ['foo' => 1, 'bar' => 2, 'baz' => 3];

// Przypisz element z kluczem "bar" do zmiennej $three
['baz' => $three] = $tablica_zrodlowa;

echo $three;    // wyświetla 3

$tablica_zrodlowa = ['foo', 'bar', 'baz'];

// Przypisz element z kluczem 2 do zmiennej $baz
[2 => $baz] = $tablica_zrodlowa;

echo $baz;    // wyświetla "baz"
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Destrukturyzacji tablicy można użyć też dla łatwej zamiany dwóch zmiennych.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;

[$b, $a] = [$a, $b];

echo $a;    // wyświetla 2
echo $b;    // wyświetla 1
?>
]]>
    </programlisting>
   </informalexample>

   <note>
    <para>
     Operator spread (<literal>...</literal>) nie jest obsługiwany przy przypisywaniu.
    </para>
   </note>

   <note>
    <para>
     Próba dostępu do klucza tablicy, który nie został zdefiniowany działa
     tak samo jak dostęp do dowolnej innej niezdefiniowanej zmiennej:
     zostanie pokazane ostrzeżenie <constant>E_WARNING</constant>
     (lub <constant>E_NOTICE</constant> przed PHP 8.0.0),
     a wynikiem będzie &null;.
    </para>
   </note>
  </sect3>

 </sect2><!-- end syntax -->
 
 <sect2 xml:id="language.types.array.useful-funcs">
  <title>Przydatne funkcje</title>

  <para>
   Istnieje sporo funkcji przydatnych przy pracy z tablicami. Zobacz
   sekcję <link linkend="ref.array">funkcje tablicowe</link>.
  </para>

  <note>
   <para>
    Funkcja <function>unset</function> pozwala na usuwanie kluczy z
    tablicy. Pamiętaj, że tablica <emphasis>nie</emphasis> zostanie
    przeindeksowana. Jeśli chcesz usunąć wartość i przeindeksować tablicę,
    możesz po usunięciu użyć funkcji
    <function>array_values</function>.
   </para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'raz', 2 => 'dwa', 3 => 'trzy');
unset($a[2]);
/* stworzy tablicę, którą zdefiniowalibyśmy następująco
   $a = array(1 => 'raz', 3 => 'trzy');
   a NIE
   $a = array(1 => 'raz', 2 =>'trzy');
*/

$b = array_values($a);
// Teraz tablica $b to array(0 => 'raz', 1 =>'trzy')
?>
]]>
    </programlisting>
   </informalexample>
  </note> 

  <para>
   Struktura kontrolna &foreach;
   została stworzona specjalnie dla tablic. Pozwala na
   przechodzenie po tablicy w łatwy sposób.
  </para>
 </sect2>
 
 <sect2 xml:id="language.types.array.donts">
  <title>Co robić i czego nie robić z tablicami</title>

  <sect3 xml:id="language.types.array.foo-bar">
   <title>Czemu <literal>$foo[bar]</literal> jest złe?</title>

   <para>
    Zawsze używaj cudzysłowów lub apostrofów wokół ciągu znaków reprezentującego dosłowny klucz tablicy. Na przyklad
    <literal>$foo['bar']</literal> jest poprawne, a
    <literal>$foo[bar]</literal> nie jest. Dlaczego? W starszych skryptach wciąż
    można znaleźć tego typu składnię:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'wróg';
echo $foo[bar];
// itd
?>
]]>
    </programlisting>
   </informalexample>
   
   <para>
    To działa, ale jest niepoprawne. Ten kod ma niezdefiniowaną
    stałą (<literal>bar</literal>) a nie ciąg znaków (<literal>'bar'</literal> - zwróć uwagę na
    apostrofy). Działa to tylko dlatego, że PHP automatycznie konwertuje
    <emphasis>nieosłonięty ciąg znaków</emphasis> (ciąg znaków bez cudzysłowów/apostrofów, który
    nie odnosi się do żadnego znanego symbolu) na <type>string</type>, który
    zawiera ten nieosłonięty ciąg znaków. Na przykład, jeśli w skrypcie
    nie została zdefiniowana stała nazywająca się <constant>bar</constant>, to PHP podstawi
    w jej miejsce ciąg znaków <literal>'bar'</literal>.
   </para>
   <warning>
    <simpara>
     Ten awaryjny sposób traktowania niezdefiniowanych stałych jako nieosłoniętych ciągów znaków powoduje błąd
     poziomu <constant>E_NOTICE</constant>.
     Jest to przestarzałe od PHP 7.2.0 i powoduje błąd
     poziomu <constant>E_WARNING</constant>.
     Od PHP ta funkcjonalność została usunięta i rzuca
     wyjątek typu <classname>Error</classname>.
    </simpara>
   </warning>

   <note>
    <simpara>
     Nie oznacza to, że musisz <emphasis>zawsze</emphasis> używać apostrofów/cudzysłowów wokół klucza. Nie
     używaj ich jeśli klucze są <link linkend="language.constants">stałymi</link> lub
     <link linkend="language.variables">zmiennymi</link>, ponieważ w ten sposób
     uniemożliwisz PHP zinterpretowanie ich.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Prosta tablica:
$tablica = array(1, 2);
$count = count($tablica);
for ($i = 0; $i < $count; $i++) {
    echo "\nSprawdzanie $i: \n";
    echo "Źle: " . $tablica['$i'] . "\n";
    echo "Dobrze: " . $tablica[$i] . "\n";
    echo "Źle: {$tablica['$i']}\n";
    echo "Dobrze: {$tablica[$i]}\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    &example.outputs;
    <screen>
<![CDATA[
Sprawdzanie 0: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Źle: 
Dobrze: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Źle: 
Dobrze: 1

Checking 1: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Źle: 
Dobrze: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Źle: 
Dobrze: 2
]]>        
    </screen>
   </note>

   <para>
    Więcej przykładów pokazujących to zachowanie:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// Pokaż wszystkie błędy
error_reporting(E_ALL);

$tablica = array('owoc' => 'jabłko', 'warzywo' => 'marchewka');

// Poprawnie
print $tablica['owoc'];  // jabłko
print $tablica['warzywo']; // marchewka

// Niepoprawnie. Działa, ale PHP pokazuje błąd o poziomie E_NOTICE, ze względu
// na niezdefiniowaną stałą nazwaną owoc
// 
// Notice: Use of undefined constant owoc - assumed 'owoc' in...
print $tablica[owoc];    // jabłko

// Zdefiniujmy stała aby pokazać co się dzieje. Od teraz do stałej
// nazywającej się owoc przypisujemy wartość 'warzywo'.
define('owoc', 'warzywo');

// Zwróć uwagę na różnicę
print $tablica['owoc'];  // jabłko
print $tablica[owoc];    // marchewka

// Poniższe jest poprawne ponieważ występuje w ciągu znaków. Wyszukiwanie stałych
// nie odbywa się wewnątrz ciągu znaków, więc tu nie wystąpi E_NOTICE
print "To jest $tablica[owoc]";      // To jest jabłko

// Z jednym wyjątkiem: nawiasy okalające tablice wewnątrz ciągów znaków pozwalają
// na interpretowanie stałych
print "To jest {$tablica[owoc]}";    // To jest marchewka
print "To jest {$tablica['owoc']}";  // To jest jabłko

// Konkatenacja też jest możliwa
print "To jest " . $tablica['owoc']; // To jest jabłko
?>
]]>
    </programlisting>
   </informalexample>
   <informalexample>
    <programlisting role="php">
     <![CDATA[
// Poniższe nie zadziała i będzie skutkowało błędem parsowania tego typu:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Odnosi się to oczywiście także do używania superglobalnych wewnątrz ciągów znaków
print "To jest $tablica['owoc']";
print "To jest $_GET['foo']";
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Jeśli dyrektywa <link linkend="ini.error-reporting">error_reporting</link> jest ustawiona tak,
    by pokazywać błędy o poziomie <constant>E_NOTICE</constant> (czyli na przykład
    na <constant>E_ALL</constant>), to takie przypadki będą natychmiast
    widoczne. Domyślnie
    <link linkend="ini.error-reporting">error_reporting</link> nie pokazuje
    takich komunikatów.
   </para>

   <para>
    Jak wspomniano w sekcji o <link linkend="language.types.array.syntax">składni</link>,
    zawartością nawiasów kwadratowych ('<literal>[</literal>' i
    '<literal>]</literal>') musi być wyrażenie. Oznacza to, że kod taki jak
    ten działa:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo $tablica[funkcja($bar)];
?>
]]>
    </programlisting>
   </informalexample>
   
   <para>
    Jest to przykład użycia wartości zwracanej przez funkcję jako klucza tablicy. PHP
    będzie także rozumieć stałe:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "Wystąpił błąd krytyczny";
$error_descriptions[E_WARNING] = "PHP wygenerowało ostrzeżenie";
$error_descriptions[E_NOTICE]  = "To jest tylko komunikat informacyjny";
?>
]]>
    </programlisting>
   </informalexample>
   
   <para>
    Zauważ, że <constant>E_ERROR</constant> jest też poprawnym identyfikatorem, tak jak
    <literal>bar</literal> w pierwszym przykładzie. Lecz ostatni przykład jest tak naprawdę
    równoważny z napisaniem:
   </para>
  
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "Wystąpił błąd krytyczny";
$error_descriptions[2] = "PHP wygenerowało ostrzeżenie";
$error_descriptions[8] = "To jest tylko komunikat informacyjny";
?>
]]>
    </programlisting>
   </informalexample>
   
   <para>
    ponieważ wartością stałej <constant>E_ERROR</constant> jest <literal>1</literal> itd.
   </para>

   <sect4 xml:id="language.types.array.foo-bar.why">
    <title>Więc dlaczego jest to złe?</title>

    <para>
     W jakimś momencie w przyszłości zespół PHP może dodać nową
     stałą lub słowo kluczowe lub stała w innym kodzie może kolidować. Na
     przykład błędem jest już użycie słów <literal>empty</literal> i
     <literal>default</literal>, bo są to
     <link linkend="reserved">zastrzeżone słowa kluczowe</link>.
    </para>

    <note>
     <simpara>
      Podsumowując, wewnątrz ciągów znaków otoczonych cudzysłowami poprawne jest
      nieotaczanie kluczy tablicy apostrofami lub cudzysłowami, więc zapis <literal>"$foo[bar]"</literal>
      jest poprawny. Zobacz powyższe przykłady, aby zrozumieć, dlaczego tak jest oraz zapoznaj się z sekcją
      o <link linkend="language.types.string.parsing">parsowaniu zmiennych w
      ciągach znaków</link>.
     </simpara>
    </note>

   </sect4>
  </sect3>
 </sect2>

 <sect2 xml:id="language.types.array.casting">
  <title>Konwersja na tablicę</title>
  
  <para>
   Dla typów <type>int</type>, <type>float</type>,
   <type>string</type>, <type>bool</type> and <type>resource</type>
   konwersja wartości na tablicę stworzy tablicę z jednym
   elementem z indeksem zero i wartością skalarną, która została skonwertowana. Innymi
   słowy kod <code>(array) $wartośćSkalarna</code> działa tak samo jak
   <literal>array($wartośćSkalarna)</literal>.
  </para>
  
  <para>
   Gdy obiekt jest konwertowany na tablicę, wynikiem
   jest tablica, której elementami są właściwości
   obiektu. Klucze to nazwy tych właściwości z kilkoma istotnymi
   wyjątkami: właściwości, których nazwy to liczby są niedostępne,
   prywatne właściwości mają swoje klucze poprzedzone nazwą klasy,
   właściwości protected mają swoje klucze poprzedzone znakiem "*". Te
   właściwości poprzedzone innymi znakami mają też bajty <literal>NUL</literal> po obu stronach.
   Niezainicjalizowane <link linkend="language.oop5.properties.typed-properties">otypowane właściwości</link>
   są po cichu odrzucane podczas konwersji.
  </para>

  <informalexample>
   <programlisting role="php">
    <![CDATA[
<?php

class A {
    private $B;
    protected $C;
    public $D;
    function __construct()
    {
        $this->{1} = null;
    }
}

var_export((array) new A());
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
    <![CDATA[
array (
  '' . "\0" . 'A' . "\0" . 'B' => NULL,
  '' . "\0" . '*' . "\0" . 'C' => NULL,
  'D' => NULL,
  1 => NULL,
)
]]>
   </screen>
  </informalexample>

  <para>
   Te bajty <literal>NUL</literal> mogą powodować nieodczekiwane zachowanie:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

class A {
    private $A; // Kluczem stanie się '\0A\0A'
}

class B extends A {
    private $A; // Kluczem będzie '\0B\0A'
    public $AA; // Kluczem będzie 'AA'
}

var_dump((array) new B());
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
    <![CDATA[
array(3) {
  ["BA"]=>
  NULL
  ["AA"]=>
  NULL
  ["AA"]=>
  NULL
}
]]>
   </screen>
  </informalexample>

  <para>
   Będzie wydawać się, że istnieją dwa klucze o nazwie "AA", choć jeden z nich tak
   naprawdę nazywa się '\0A\0A'.
  </para>
  
  <para>
   Konwersja &null; na tablicę skutkuje pustą
   tablicą.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.comparing">
  <title>Porównywanie</title>

  <para>
   Porównywanie tablic jest możliwe przy użyciu funkcji
   <function>array_diff</function> i
   <link linkend="language.operators.array">operatorów tablicowych</link>.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.unpacking">
  <title>Odpakowywanie tablic</title>

  <para>
   Tablica poprzedzona znakami <code>...</code> zostanie rozpakowana w miejscu podczas definiowania tablicy.
   Tylko tablice i obiekty, które implementują <interfacename>Traversable</interfacename> mogą być rozpakowane.
   Rozpakowywanie tablic przy użyciu <code>...</code> jest dostępne od PHP 7.4.0.
  </para>

  <para>
   Możliwe jest wielokrotne odpakowywanie i dodawanie zwykłych elementów przed i po operatorze <code>...</code>:

   <example>
    <title>Proste odpakowywanie tablicy</title>
    <programlisting role="php">
<![CDATA[
<?php
// Użycie krótkiej składni tablicy.
// Działa też ze składnią array()
$tablica1 = [1, 2, 3];
$tablica2 = [...$tablica1]; //[1, 2, 3]
$tablica3 = [0, ...$tablica1]; //[0, 1, 2, 3]
$tablica4 = [...$tablica1, ...$tablica2, 111]; //[1, 2, 3, 1, 2, 3, 111]
$tablica5 = [...$tablica1, ...$tablica1]; //[1, 2, 3, 1, 2, 3]

function getArr() {
  return ['a', 'b'];
}
$tablica6 = [...getArr(), 'c' => 'd']; //['a', 'b', 'c' => 'd']
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   Odpakowywanie tablicy operatorem <code>...</code> używa semantyki funkcji <function>array_merge</function>.
   To znaczy, że późniejsze klucze tekstowe nadpisują te wcześniejsze, a klucze numeryczne są przenumerowywane:

   <example>
    <title>Odpakowywanie tablicy a zduplikowane klucze</title>
    <programlisting role="php">
<![CDATA[
<?php
// klucz tekstowy
$tablica1 = ["a" => 1];
$tablica2 = ["a" => 2];
$tablica3 = ["a" => 0, ...$tablica1, ...$tablica2];
var_dump($tablica3); // ["a" => 2]

// klucz numeryczny
$tablica4 = [1, 2, 3];
$tablica5 = [4, 5, 6];
$tablica6 = [...$tablica4, ...$tablica5];
var_dump($tablica6); // [1, 2, 3, 4, 5, 6]
// Odpowiada to [0 => 1, 1 => 2, 2 => 3, 3 => 4, 4 => 5, 5 => 6]
// gdzie oryginalne klucze numeryczne nie zostały zachowane.
?>
]]>
    </programlisting>
   </example>
  </para>

  <note>
   <para>
    Klucze, które nie są liczbami ani ciągami znaków rzucają wyjątek <classname>TypeError</classname>.
    Takie klucze mogą być wygenerowane tylko przez obiekt implementujący <interfacename>Traversable</interfacename>.
   </para>
  </note>
  <note>
   <para>
    Przed PHP 8.1 odpakowywanie tablicy z kluczami tekstowymi nie było wspierane.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php

$tablica1 = [1, 2, 3];
$tablica2 = ['a' => 4];
$tablica3 = [...$tablica1, ...$tablica2];
// Fatal error: Uncaught Error: Cannot unpack array with string keys in example.php:5

$tablica4 = [1, 2, 3];
$tablica5 = [4, 5];
$tablica6 = [...$tablica4, ...$tablica5]; // działa. [1, 2, 3, 4, 5]
?>
]]>
    </programlisting>
   </informalexample>
  </note>

 </sect2>

 <sect2 xml:id="language.types.array.examples">
  <title>Przykłady</title>

  <para>
   Typ tablicowy w PHP jest bardzo wszechstronny. Oto niektóre przykłady:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// To:
$a = array( 'kolor' => 'czerwony',
            'smak' => 'słodki',
            'kształt' => 'okrągły',
            'nazwa'  => 'jabłko',
            4        // kluczem będzie 0
          );

$b = array('a', 'b', 'c');

// ...jest dokładnym odpowiednikiem tego:
$a = array();
$a['kolor'] = 'czerwony';
$a['smak'] = 'słodki';
$a['kształt'] = 'okrągły';
$a['nazwa']  = 'jabłko';
$a[]        = 4;        // kluczem będzie 0

$b = array();
$b[] = 'a';
$b[] = 'b';
$b[] = 'c';

// Po wykonaniu powyższego kodu $a będzie tablicą
// array('kolor' => 'czerwony', 'smak' => 'słodki', 'kształt' => 'okrągły', 
// 'nazwa' => 'jabłko', 0 => 4) a $b będzie tablicą 
// array(0 => 'a', 1 => 'b', 2 => 'c'), lub po prostu array('a', 'b', 'c').
?>
]]>
   </programlisting>
  </informalexample>

  <example>
   <title>Użycie array()</title>
   <programlisting role="php">
<![CDATA[
<?php
// Tablica jako mapa
$mapa = array( 'version'    => 4,
               'OS'         => 'Linux',
               'lang'       => 'english',
               'short_tags' => true
             );
            
// tylko klucze numeryczne
$tablica = array( 7,
                8,
                0,
                156,
                -10
              );
// to samo co: array(0 => 7, 1 => 8, ...)

$switching = array(         10, // klucz = 0
                    5    =>  6,
                    3    =>  7, 
                    'a'  =>  4,
                            11, // klucz = 6 (największym z kluczy numerycznych był 5)
                    '8'  =>  2, // klucz = 8 (liczba!)
                    '02' => 77, // klucz = '02'
                    0    => 12  // wartość 10 będzie nadpisana przez 12
                  );
                  
// pusta tablica
$empty = array();         
?>
]]>
<!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
   </programlisting>
  </example>

  <example xml:id="language.types.array.examples.loop">
   <title>Kolekcja</title>
   <programlisting role="php">
<![CDATA[
<?php
$kolory = array('czerwony', 'niebieski', 'zielony', 'żółty');

foreach ($kolory as $kolor) {
    echo "Czy lubisz $kolor?\n";
}

?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Czy lubisz czerwony?
Czy lubisz niebieski?
Czy lubisz zielony?
Czy lubisz żółty?
]]>
   </screen>
  </example>
  
  <para>
   Bezpośrednia zmiana wartości tablicy jest możliwa
   jeśli przekazano je jako referencję.
  </para>

  <example xml:id="language.types.array.examples.changeloop">
   <title>Zmiana elementu w pętli</title>
   <programlisting role="php">
<![CDATA[
<?php
foreach ($kolory as &$kolor) {
    $kolor = mb_strtoupper($kolor);
}
unset($kolor); upewnij się, że kolejne zapisy do
$kolor nie będą modyfikować ostatniego elementu tablicy */

print_r($kolory);
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => CZERWONY
    [1] => NIEBIESKI
    [2] => ZIELONY
    [3] => ŻÓŁTY
)
]]>
   </screen>
  </example>

  <para>
   Ten przykład tworzy tablicę indeksowaną od 1.
  </para>

  <example>
   <title>Tablica indeksowana od 1</title>
   <programlisting role="php">
<![CDATA[
<?php
$pierwszyKwartal  = array(1 => 'styczeń', 'luty', 'marzec');
print_r($pierwszyKwartal);
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array 
(
    [1] => 'styczeń'
    [2] => 'luty'
    [3] => 'marzec'
)
]]>   
   </screen>
  </example>

  <example>
   <title>Wypełnianie tablicy</title>
   <programlisting role="php">
<![CDATA[
<?php
// wypełnij tablicę wszystkimi elementami katalogu
$uchwyt = opendir('.');
while (false !== ($plik = readdir($uchwyt))) {
    $pliki[] = $plik;
}
closedir($uchwyt); 
?>
]]>
   </programlisting>
  </example>

  <para>
   Tablice są sortowane. Kolejność może być zmieniona przy użyciu różnych
   funkcji sortujących. Zobacz sekcję o <link linkend="ref.array">funkcjach tablicowych</link>,
   aby dowiedzieć się więcej. Funkcja <function>count</function> może być
   użyta, aby policzyć liczbę elementów w tablicy.
  </para>

  <example>
   <title>Sortowanie tablicy</title>
   <programlisting role="php">
<![CDATA[
<?php
sort($pliki);
print_r($pliki);
?>
]]>
   </programlisting>
  </example>

  <para>
   Ponieważ wartość tablicy może być dowolna, może nią być też
   inna tablica. Pozwala to na tworzenie rekurencyjnych
   i wielowymiarowych tablic.
  </para>

  <example>
   <title>Tablice rekurencyjne i wielowymiarowe</title>
   <programlisting role="php">
<![CDATA[
<?php
$owoce = array ( "owoce"  => array ( "a" => "pomarańcza",
                                       "b" => "banan",
                                       "c" => "jabłko"
                                     ),
                  "liczby" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "dołki"   => array (      "pierwszy",
                                       5 => "drugi",
                                            "trzeci"
                                     )
                );

// Kilka przykładów odniesienia się do wartości tablicy powyżej
echo $owoce["dołki"][5];    // wyświetla "drugi"
echo $owoce["owoce"]["a"];  // wyświetla "pomarańcza"
unset($owoce["dołki"][0]);  // usuń "pierwszy"

// Stwórz nową tablicę wielowymiarową
$juices["jabłko"]["zielone"] = "dobre"; 
?>
]]>
   </programlisting>
  </example>

  <para>
   Przypisanie tablicy zawsze powoduje kopiowanie wartości. Użyj
   <link linkend="language.operators">operatora referencji</link>, aby skopiować
   tablicę przez referencję.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$tablica1 = array(2, 3);
$tablica2 = $tablica1;
$tablica2[] = 4; // $tablica2 została zmieniona,
                 // $tablica1 to wciąż array(2, 3)
             
$tablica3 = &$tablica1;
$tablica3[] = 4; // teraz $tablica1 i $tablica3 są takie same
?>
]]>
   </programlisting>
  </informalexample>

 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
