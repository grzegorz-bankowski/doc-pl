<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: ef5a00895dbb9a3abbe3edc03d1f966b239a2eb2 Maintainer: sobak Status: ready -->
<sect1 xml:id="language.types.string">
 <title>Ciągi znaków</title>

 <para>
  Ciąg znaków (<type>string</type>) to lista znaków, gdzie znak to
  to samo co bajt. Oznacza to, że PHP obsługuje tylko zestaw 256 znaków,
  a więc nie oferuje natywnej obsługi Unikodu. Zapoznaj się ze
  <link linkend="language.types.string.details">szczegółami typu
  string</link>.
 </para>

 <note>
  <simpara>
   W kompilacjach 32-bitowych <type>string</type> może mieć rozmiar to 2GB
   (maksymalnie 2147483647 bajtów).
  </simpara>
 </note>

 <sect2 xml:id="language.types.string.syntax">
  <title>Składnia</title>

  <para>
   Literał <type>string</type> może być określony na cztery różne sposoby:
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">używając apostrofów</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">używając cudzysłowów</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">składnią heredoc</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">składnią nowdoc</link>
    </simpara>
   </listitem>
  </itemizedlist>

  <sect3 xml:id="language.types.string.syntax.single">
   <title>Używając apostrofów</title>

   <para>
    Najprostszym sposobem określenia ciągu znaków jest otoczenie go pojedynczymi
    cudzysłowami (znak <literal>'</literal>).
   </para>

   <para>
    Aby określić dosłowny znak apostrofu, poprzedź go znakiem odwrotnego ukośnika
    (<literal>\</literal>). Aby określić dosłowny znak odwrotnego ukośnika, podwój go
    (<literal>\\</literal>). Wszystkie inne wystąpienia odwrotnych ukośników będą traktowane
    jak dosłowny odwrotny ukośnik: oznacza to, że inne sekwencje ucieczkowe, do których
    możesz być przyzwyczajony, takie jak <literal>\r</literal> czy <literal>\n</literal>,
    będą wyświetlone dosłownie i nie mają żadnego specjalnego
    znaczenia.
   </para>

   <note>
    <simpara>
     W przeciwieństwie do składni <link linkend="language.types.string.syntax.double">cudzysłowów</link>
     i <link linkend="language.types.string.syntax.heredoc">heredoc</link>,
     <link linkend="language.variables">zmienne</link> oraz sekwencje ucieczkowe
     dla znaków specjalnych <emphasis>nie</emphasis> są rozwiązywane, jeśli występują
     w ciągu znaków otoczonym apostrofami.
    </simpara>
   </note>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo 'to jest prosty string';

echo 'Możesz też zawierać nowe linie w
ciągach znaków w ten sposób, jako że
jest to obsługiwane';

// Wyświetla: Arnold powiedział kiedyś: "I'll be back"
echo 'Arnold powiedział kiedyś: "I\'ll be back"';

// Wyświetla: Skasowałeś C:\*.*?
echo 'Skasowałeś C:\\*.*?';

// Wyświetla: Skasowałeś C:\*.*?
echo 'Skasowałeś C:\*.*?';

// Wyświetla: To nie będzie rozwinięte do \n nowej linii
echo 'To nie będzie rozwinięte do \n nowej linii';

// Wyświetla: Zmienne też $nie $sa rozwiązywane
echo 'Zmienne też $nie $sa rozwiązywane';
?>
]]>
    </programlisting>
   </informalexample>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.double">
   <title>Używając cudzysłowów</title>

   <para>
    Jeśli <type>string</type> jest otoczony cudzysłowem (<literal>"</literal>), to PHP
    zinterpretuje następujące sekwencje ucieczkowe dla znaków specjalnych:
   </para>

   <table>
    <title>Rozszerzane znaki</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Sekwencja</entry>
       <entry>Znaczenie</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>nowa linia (LF lub 0x0A (10) w ASCII)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>znak powrotu karetki (CR lub 0x0D (13) w ASCII)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>tabulator poziomy (HT lub 0x09 (9) w ASCII)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>tabulator pionowy (VT lub 0x0B (11) w ASCII)</entry>
      </row>
      <row>
       <entry><literal>\e</literal></entry>
       <entry>escape (ESC lub 0x1B (27) w ASCII)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>znak formularza (FF lub 0x0C (12) w ASCII)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>odwrotny ukośnik</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>znak dolara</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>cudzysłów</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        Wartość ósemkowa: sekwencja znaków pasująca do wyrażenia regularnego <literal>[0-7]{1,3}</literal>
        jest znakiem w notacji ósemkowej (np. <literal>"\101" === "A"</literal>),
        która po cichu przepełnia się aby zmieścić się w bajcie (np. <literal>"\400" === "\000"</literal>)
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        Wartość szesnastkowa: sekwencja znaków pasująca do wyrażenia regularnego
        <literal>[0-9A-Fa-f]{1,2}</literal> jest znakiem w notacji szesnastkowej
        (np. <literal>"\x41" === "A"</literal>)
       </entry>
      </row>
      <row>
       <entry><literal>\u{[0-9A-Fa-f]+}</literal></entry>
       <entry>
        Unicode: sekwencja znaków pasująca do wyrażenia regularnego <literal>[0-9A-Fa-f]+</literal>
        jest codepointem Unicode, który będzie wyświetlony w ciągu znaków jako reprezentacja tego codepointa w UTF-8.
        Nawiasy klamrowe są wymagane dla sekwencji. Np. <literal>"\u{41}" === "A"</literal>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Tak jak w ciągach znaków w apostrofach, poprzedzenie każdego innego znaku odwrotnym ukośnikiem,
    też wyświetli ten odwrotny ukośnik.
   </para>

   <para>
    Najważniejszą funkcjonalnością ciągów znaków w cudzysłowach jest fakt,
    że nazwy zmiennych są rozwiązywane. Zobacz sekcję o
    <link linkend="language.types.string.parsing">interpolacji stringów</link>, aby
    dowiedzieć się więcej.
   </para>
  </sect3>

  <sect3 xml:id="language.types.string.syntax.heredoc">
   <title>Heredoc</title>

   <simpara>
    Trzecim sposobem ograniczenia ciągów znaków jest składnia heredoc:
    <literal>&lt;&lt;&lt;</literal>. Po tym operatorze umieszcza się identyfikator,
    a potem nową linię. Potem sam ciąg znaków, a potem ponownie ten
    sam identyfikator, aby zamknąć ciąg znaków.
   </simpara>

   <simpara>
    Zamykający identyfikator może być wcięty spacją lub tabulatorem, w tym wypadku
    wcięcia zostaną wycięte ze wszystkich linii w ciągu heredoc.
    Przed PHP 7.3.0 końcowy identyfikator <emphasis>musiał</emphasis>
    zaczynać się w pierwszej kolumnie linii.
   </simpara>

   <simpara>
    Ponadto, zamykający identyfikator musi stosować się do tych samych reguł nazewnictwa co każda
    inna etykieta w PHP: musi zawierać tylko znaki alfanumeryczne i
    podkreślenia i musi zaczynać się od znaku niebędącego liczbą ani podkreśleniem.
   </simpara>

   <example>
    <title>Podstawowy przykład Heredoc od PHP 7.3.0</title>
    <programlisting role="php">
<![CDATA[
<?php
// brak wcięć
echo <<<END
      a
     b
    c
\n
END;

// 4 spacje wcięcia
echo <<<END
      a
     b
    c
    END;
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
      a
     b
    c

  a
 b
c
]]>
    </screen>
   </example>

   <simpara>
    Jeżeli zamykający identyfikator jest wcięty bardziej niż dowolna z linii ciała, to rzucony zostanie <classname>ParseError</classname>:
   </simpara>

   <example>
    <title>Zamykający identyfikator nie może być wcięty bardziej niż żadna z linii ciała</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<END
  a
 b
c
   END;
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
PHP Parse error:  Invalid body indentation level (expecting an indentation level of at least 3) in example.php on line 4
]]>
    </screen>
   </example>

   <simpara>
    Jeżeli zamykający identyfikator jest wcięty, to mogą byc też użyte tabulatory,
    ale tabulatory i spacje <emphasis>nie mogą</emphasis> być wymieszane przy tworzeniu
    wcięcia identyfikatora końcowego. W każdym z tych wypadków zostanie rzucony <classname>ParseError</classname>.

    Te ograniczenia białych znaków zostały dodane ponieważ mieszanie tabulatorów
    i spacji we wcięciach jest szkodliwe dla czytelności.
   </simpara>

   <example>
    <title>Inne wcięcia dla ciała (spacje) i zamykającego identyfikatora</title>
    <programlisting role="php">
<![CDATA[
<?php
// Żaden z fragmentów kodu poniżej nie zadziała.

Inne wcięcia dla ciała (spacje) i zamykającego identyfikatora (taby)
{
	echo <<<END
	 a
		END;
}

// mieszanie spacji z tabulatorami w ciele
{
    echo <<<END
    	a
     END;
}

// mieszanie spacji i tabulatorów we wcięciach identyfikatora zamykającego
{
	echo <<<END
		  a
		 END;
}
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
PHP Parse error:  Invalid indentation - tabs and spaces cannot be mixed in example.php line 8
]]>
    </screen>
   </example>

   <simpara>
    Po zamykającym identyfikatorze dla ciała stringu heredoc nie musi
    występować średnik lub nowa linia. Na przykład następujący kod
    jest dozwolony od PHP 7.3.0:
   </simpara>

   <example>
    <title>Kontynuacja wyrażenia po zamykającym identyfikatorze</title>
    <programlisting role="php">
<![CDATA[
<?php
$values = [<<<END
a
  b
    c
END, 'd e f'];
var_dump($values);
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
array(2) {
  [0] =>
  string(11) "a
  b
    c"
  [1] =>
  string(5) "d e f"
}
]]>
    </screen>
   </example>

   <warning>
    <simpara>
     Jeżeli identyfikator zamykający został znaleziony na początku linii, to
     niezależnie czy był on częścią innego słowa, może być on być uznany jako
     identyfikator zamykający i może spowodować błąd parsowania (<classname>ParseError</classname>).
    </simpara>

    <example>
     <title>Zamykający identyfikator w ciele ciągu znaków może powodować błąd parsowania</title>
     <programlisting role="php">
<![CDATA[
<?php
$values = [<<<END
a
b
END ING
END, 'd e f'];
]]>
     </programlisting>
     &example.outputs.73;
    <screen>
<![CDATA[
PHP Parse error:  syntax error, unexpected identifier "ING", expecting "]" in example.php on line 6
]]>
     </screen>
    </example>

    <simpara>
     Aby uniknąć tego problemu, bezpiecznie jest przestrzegać prostej zasady:
     <emphasis>nie wybieraj identyfikatora zamykającego, który może pojawić się
     w ciele tekstu</emphasis>.
    </simpara>

   </warning>

   <warning>
    <simpara>
     Przed PHP 7.3.0 należy koniecznie zauważyć, że pierwsza linia z
     identyfikatorem zamykającym nie może zawierać innych znaków, poza średnikiem
     (<literal>;</literal>).
     Oznacza to zasadniczo, że identyfikator
     <emphasis>nie może być wcięty</emphasis> i zarówno przed, jak i po identyfikatorze,
     nie mogą znajdować się żadne spacje ani taby. Trzeba też sobie zdać sprawę, że
     pierwszym znakiem po identyfikatorze zamykającym musi być nowa linia,
     określona przez używany system operacyjny. Będzie to <literal>\n</literal> w
     systemach UNIX, w tym macOS. Po końcowym identyfikatorze zamykającym także musi
     znaleźć się nowa linia.
    </simpara>

    <simpara>
     Jeżeli ta zasada nie jest przestrzegana i identyfikator zamykający nie jest "czysty", nie
     będzie on uznany za identyfikator zamykający i PHP będzie szukał go dalej.
     Jeżeli przed końcem obecnego pliku nie zostanie znaleziony prawidłowy identyfikator
     zamykający, zostanie zgłoszony bład parsowania w ostatniej linii pliku.
    </simpara>

    <example>
     <title>Niepoprawny przykład, przed PHP 7.3.0</title>
     <programlisting role="php">
      <!-- Ten przykład jest NIEPOPRAWNY -->
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
    EOT;
}
// Identyfikator nie może być wcięty
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Poprawny przykład, nawet przed PHP 7.3.0</title>
     <programlisting role="php">
      <!-- ten przykład jest POPRAWNY -->
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>

    <para>
     Ciągi heredoc zawierające zmienne nie mogą być używane do inicjalizowania właściwości klas.
    </para>

   </warning>

   <para>
    Ciągi heredoc zachowują się tak jak zwykłe ciągi umieszczone w cudzysłowie, ale
    bez użycia cudzysłowu. Oznacza to, że cudzysłowy w ciągach heredoc nie potrzebują
    znaków ucieczki, ale kody ucieczki wymienione powyżej wciąż mogą być używane. Zmienne
    są rozszerzane, ale przy złożonych wyrażeniach zmiennych należy zachować tę samą uwagę
    co dla zwykłych <type>string</type>ów.
   </para>

   <example>
    <title>Przykład obsługi cudzysłowów w ciągach heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Przykład ciągu
na klilka linii
używającego składni heredoc.
EOD;

/* Bardziej złożony przykład, ze zmiennymi */
class foo
{
    var $foo;
    var $bar;

    function __construct()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
My name is "MyName". I am printing some Foo.
Now, I am printing some Bar2.
This should print a capital 'A': A]]>
    </screen>
   </example>

   <para>
    Możliwe jest też użycie składni Heredoc do przekazania danych do argumentów
    funkcji:
   </para>

   <example>
    <title>Przykład użycia Heredoc dla argumentów</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(array(<<<EOD
foobar!
EOD
));
?>
]]>
    </programlisting>
   </example>

   <para>
    Możliwe jest inicjalizowanie zmiennych statycznych i właściwości/stałych
    w klasach przy użyciu składni Heredoc:
   </para>

   <example>
    <title>Użycie Heredoc do zainicjalizowania wartości statycznych</title>
    <programlisting role="php">
<![CDATA[
<?php
// Zmienne statyczne
function foo()
{
    static $bar = <<<LABEL
Nic tu nie ma...
LABEL;
}

// Zmienne/stałe klas
class foo
{
    const BAR = <<<FOOBAR
Przykład stałej
FOOBAR;

    public $baz = <<<FOOBAR
Przykład właściwości
FOOBAR;
}
?>
]]>
    </programlisting>
   </example>

   <para>
    Otwierający identyfikator Heredoc może być opcjonalnie
    ujęty w cudzysłów:
   </para>

   <example>
    <title>Użycie cudzysłowu w Heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<"FOOBAR"
Hello World!
FOOBAR;
?>
]]>
    </programlisting>
   </example>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>

   <para>
    Ciągi Nowdoc są tym dla ciągów w apostrofach czym ciągi heredoc są dla ciągów
    w cudzysłowie. Nowdoc jest określany podobnie do heredoc, ale wewnątrz ciągu nowdoc <emphasis>nie
    jest wykonywana interpolacja</emphasis>. Ta konstrukcja jest idealna
    do umieszczania kodu PHP lub innych dużych bloków tekstu bez potrzeby
    dodawania znaków ucieczki. Niektóre z jej cech są podobne do konstrukcji
    <literal>&lt;![CDATA[ ]]&gt;</literal> w SGML, jako że definiuje ona
    blok tekstu, który nie powinien być parsowany.
   </para>

   <para>
    Nowdoc używa identycznej sekwencji <literal>&lt;&lt;&lt;</literal>
    jak ciągi heredoc, ale identyfikator następuje po niej musi być otoczony
    apostrofami, np. <literal>&lt;&lt;&lt;'EOT'</literal>. Wszystkie reguły odnośnie
    identyfikatorów heredoc stosują się też do identyfikatorów nowdoc, szczególnie te
    odnoszące się do występowania identyfikatora zamykającego.
   </para>

   <example>
    <title>Przykład cudzysłowów w ciągach nowdoc</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<'EOD'
Przykład ciągu znaków rozpościerającego się na wiele linii
używającego składni nowdoc. Odwrotne ukośniki są zawsze traktowane dosłownie,
na przykład \\ czy \'.
EOD;
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Przykład ciągu znaków rozpościerającego się na wiele linii
używającego składni nowdoc. Odwrotne ukośniki są zawsze traktowane dosłownie,
na przykład \\ czy \'.
]]>
    </screen>
   </example>

   <example>
    <title>Przykład cudzysłowów w ciągach nowdoc zawierających zmienne</title>
    <programlisting role="php">
<![CDATA[
<?php
class foo
{
    public $foo;
    public $bar;

    function __construct()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<'EOT'
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should not print a capital 'A': \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should not print a capital 'A': \x41]]>
    </screen>
   </example>

   <example>
    <title>Przykład danych statycznych</title>
    <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
    </programlisting>
   </example>

  </sect3>

  <sect3 xml:id="language.types.string.parsing">
   <title>Interpolacja ciągów</title>

   <simpara>
    Kiedy <type>string</type> jest zawarty w cudzysłowie lub wewnątrz heredoc,
    <link linkend="language.variables">zmienne</link> wewnątrz niego są zamieniane.
   </simpara>

   <simpara>
    Istnieją dwa typy składni:
    <link linkend="language.types.string.parsing.basic">podstawowa</link> i
    <link linkend="language.types.string.parsing.advanced">zaawansowana</link>.
    Podstawowa składnia jest najbardziej powszechna i najwygodniejsza. Pozwala
    na umieszczenie zmiennej, wartości tablicy lub właściwości obiektu
    wewnątrz ciągu znaków w prosty sposób.
   </simpara>

   <sect4 xml:id="language.types.string.parsing.basic">
    <title>Składnia podstawowa</title>
    <simpara>
     Jeżeli napotkany zostanie znak dolara (<literal>$</literal>), to znaki
     następujące po nim, które mogą być użyte w nazwie zmiennej, będą interpretowane
     jako takie i nastąpi próba ich podmiany na wartość zmiennej.
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$sok = "z jabłek";

echo "Wypił sok $sok." . PHP_EOL;

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Wypił sok z jabłek.
]]>
     </screen>
    </informalexample>

    <simpara>
     Formalnie struktura składni dla podstawowej podmiany zmiennych jest
     następująca:
    </simpara>
    <informalexample>
     <programlisting>
<![CDATA[
string-variable::
     variable-name   (offset-or-property)?
   | ${   expression   }

offset-or-property::
     offset-in-string
   | property-in-string

offset-in-string::
     [   name   ]
   | [   variable-name   ]
   | [   integer-literal   ]

property-in-string::
     ->  name

variable-name::
     $   name

name::
     [a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*

]]>
     </programlisting>
    </informalexample>

    <warning>
     <para>
      Składnia <literal>${ wyrażenie }</literal> jest przestarzała od
      PHP 8.2.0, jako że może być ona zinterpretowana jako
      <link linkend="language.variables.variable">zmienne zmiennych</link>:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
const foo = 'bar';
$foo = 'foo';
$bar = 'bar';
var_dump("${foo}");
var_dump("${(foo)}");
?>
]]>
       </programlisting>
       &example.outputs.82;
       <screen>
<![CDATA[
Deprecated: Using ${var} in strings is deprecated, use {$var} instead in file on line 6

Deprecated: Using ${expr} (variable variables) in strings is deprecated, use {${expr}} instead in file on line 9
string(3) "foo"
string(3) "bar"
]]>
       </screen>
       &example.outputs;
       <screen>
<![CDATA[
string(3) "foo"
string(3) "bar"
]]>
       </screen>
      </informalexample>
      Zamiast tego powinna być użyta
      <link linkend="language.types.string.parsing.advanced">zaawansowana</link> składnia interpolacji ciągów znaków.
     </para>
    </warning>

    <note>
     <simpara>
      Jeżeli stworzenie poprawnej nazwy zmiennej, to znak dolara pozostaje
      nienaruszony w ciągu znaków:
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo "Interpolacja $  nie wydarzyła się\n";
echo "Interpolacja $\n nie wydarzyła się\n";
echo "Interpolacja $2 nie wydarzyła się\n";
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Interpolacja $  nie wydarzyła się
Interpolacja $
 nie wydarzyła się
Interpolacja $2 nie wydarzyła się
]]>
      </screen>
     </informalexample>
    </note>

    <example>
     <title>Interpolacja wartości pierwszego wymiaru tablicy lub właściwości</title>
     <programlisting role="php">
<![CDATA[
<?php
$juices = array("apple", "orange", "string_key" => "purple");

echo "He drank some $juices[0] juice.";
echo PHP_EOL;
echo "He drank some $juices[1] juice.";
echo PHP_EOL;
echo "He drank some $juices[string_key] juice.";
echo PHP_EOL;

class A {
    public $s = "string";
}

$o = new A();

echo "Object value: $o->s.";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
He drank some apple juice.
He drank some orange juice.
He drank some purple juice.
Object value: string.
]]>
     </screen>
    </example>

    <note>
     <simpara>
      Klucz tablicy nie może używać cudzysłowu ani apostrofów, a więc przy użyciu
      składni podstawowej niemożliwe jest odwołanie się do stałej jako klucza. Zamiast
      tego użyj składni
      <link linkend="language.types.string.parsing.advanced">zaawansowanej</link>.
     </simpara>
    </note>

    <simpara>
     Od PHP 7.1.0 wspierane są też <emphasis>ujemne</emphasis> indeksy
     numeryczne.
    </simpara>

    <example><title>Negatywne indeksy numeryczne</title>
     <programlisting role="php">
<![CDATA[
<?php
$string = 'string';
echo "Znak pod indeksem -2 to $string[-2].", PHP_EOL;
$string[-3] = 'o';
echo "Zmiana znaku pod indeksem -3 daje nam: $string.", PHP_EOL;
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Znak pod indeksem -2 to n.
Zmiana znaku pod indeksem -3 daje nam: strong.
]]>
     </screen>
    </example>

    <simpara>
     Dla bardziej złożonych przypadków
     musi zostać użyta składnia
     <link linkend="language.types.string.parsing.advanced">zaawansowana</link>.
    </simpara>
   </sect4>

   <sect4 xml:id="language.types.string.parsing.advanced">
    <title>Składnia zaawansowana (z klamerkami)</title>

    <simpara>
     Zaawansowana składnia pozwala na interpolację
     <emphasis>zmiennych</emphasis> z dowolnym sposobem dostępu.
    </simpara>

    <simpara>
     Przy użyciu tej składni można dołączyć dowolną zmienną
     skalarną, element tablicy lub właściwość obiektu
     (używającą <modifier>static</modifier> lub też nie),
     która ma reprezentację jako ciąg znaków.
     Wyrażenie jest zapisywany w taki sam sposób, w jaki występowałoby poza
     ciągiem znaków, a następnie opakowuje się je znakami <literal>{</literal> i
     <literal>}</literal>. Jako, że <literal>{</literal> nie może być wyescape'owane, ta
     składnia będzie rozpoznana tylko, gdy <literal>$</literal> następujace bezpośrednio
     po <literal>{</literal>. Użyj <literal>{\$</literal> jeśli chcesz
     wyświetlić dosłownie <literal>{$</literal>. Oto kilka przykładów dla rozjaśnienia:
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

const DATA_KEY = 'const-key';
$great = 'super';
$arr = [
    '1',
    '2',
    '3',
    [41, 42, 43],
    'key' => 'Wartość indeksowana',
    'const-key' => 'Klucz ze znakiem minus',
    'foo' => ['foo1', 'foo2', 'foo3']
];

// Nie zadziała, wyświetli: To jest { fantastic}
echo "To jest { $great}";

// Działa, wyświetli: To jest super
echo "To jest {$great}";

class Square {
    public $width;

    public function __construct(int $width) { $this->width = $width; }
}

$square = new Square(5);

// Działa
echo "Bok tego kwadratu ma {$square->width}00 centymetrów.";


// Działa, klucze w apostrofach lub cudzysłowie działają tylko przy składni w klamerkach
echo "To działa: {$arr['key']}";


// Działa
echo "To działa: {$arr[3][2]}";

echo "To działa: {$arr[DATA_KEY]}";

// Przy użyciu tablic wielowymiarowych w ciągach znaków, zawsze używaj
// nawiasów klamrowych
echo "To działa: {$arr['foo'][2]}";

echo "To działa: {$obj->values[3]->name}";

echo "To działa: {$obj->$staticProp}";

// Nie zadziała, wyświetli: C:\directory\{super}.txt
echo "C:\directory\{$great}.txt";

// Działa, wyświetli: C:\directory\super.txt
echo "C:\\directory\\{$great}.txt";
?>
]]>
     </programlisting>
    </informalexample>

    <note>
     <simpara>
      Jako że ta składnia pozwala na dowolne wyrażenia, możliwe jest użycie
      <link linkend="language.variables.variable">zmiennych zmiennych</link>
      w składni zaawansowanej.
     </simpara>
    </note>
   </sect4>
  </sect3>

  <sect3 xml:id="language.types.string.substr">
   <title>Dostęp do ciągów znaków i modyfikacja po znaku</title>

   <para>
    Do znaków wewnątrz ciągów znaków można uzyskać dostęp i modyfikować je
    określając przesunięcie liczone od zera dla oczekiwanego znaku,
    używając nawiasów klamrowych jak przy tablicach, np.
    <varname>$str[42]</varname>. Pomyśl o ciągu znaków jak
    o tablicy znaków pod tym kątem. Funkcje
    <function>substr</function> i <function>substr_replace</function>
    mogą być użyte jeśli chcesz wydobyć lub zmienić więcej niż jeden znak.
   </para>

   <note>
    <simpara>
     Od PHP 7.1.0 wspierane są też ujemne przesunięcia dla ciągów znaków. Określają one
     offset liczony od końca ciągu znaków.
     Wcześniej negatywne przesunięcia emitowały <constant>E_NOTICE</constant> przy odczycie
     (zwracając pusty ciąg znaków) i <constant>E_WARNING</constant> dla zapisu
     (ciąg znaków nie był zmieniany).
    </simpara>
   </note>

   <note>
    <simpara>
     Przed PHP 8.0.0 do ciągów znaków można było uzyskać dostęp, używając nawiasów klamrowych, np.
     <varname>$str{42}</varname>, aby osiągnąć ten sam efekt.
     Składnia używająca nawiasów klamrowych była przestarzała od PHP 7.4.0 i niewspierana od PHP 8.0.0.
    </simpara>
   </note>

   <warning>
    <simpara>
     Zapis do przesunięcia (offsetu) poza zasięgiem powoduje dodanie spacji do ciągu znaków.
     Typy niebędące liczbami całkowitymi są konwertowane dla liczb całkowitych.
     Niepoprawny offset powoduje wygenerowanie ostrzeżenia <constant>E_WARNING</constant>.
     Używany jest tylko pierwszy znak przypisanego ciągu znaków.
     Od PHP 7.1.0 przypisanie pustego ciągu znaków powoduje rzucenie błędu krytycznego. Wcześniej
     przypisało to bajt NULL.
    </simpara>
   </warning>

   <warning>
    <simpara>
     Wewnętrznie ciągi znaków w PHP są tablicami bajtów. W wyniku tego dostęp
     i modyfikacja stringów używając nawiasów tablicowych, nie są bezpieczne dla ciągów wielobajtowych
     i powinny być używane tylko dla stringów, które są w kodowaniu jednobajtowym, jak
     np. ISO-8859-1.
    </simpara>
   </warning>

   <note>
    <simpara>
     Od PHP 7.1.0 zastosowanie pustego operatora indeksu ciągu znaków do pustego ciągu znaków powoduje błąd
     krytyczny. Wcześniej pusty ciąg znaków był po cichu konwertowany na tablicę.
    </simpara>
   </note>

   <example>
    <title>Trochę przykładów dla ciągów znaków</title>
    <programlisting role="php">
<![CDATA[
<?php
// Pobierz pierwszy znak ciągu znaków
$str = 'To jest test.';
$first = $str[0];

// Pobierz trzeci znak ciągu znaków
$third = $str[2];

// Pobierz ostatni znak z ciągu znaków.
$str = 'This is still a test.';
$last = $str[strlen($str)-1];

// Zmodyfikuj ostatni znak ciągu znaków
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';

?>
]]>
    </programlisting>
   </example>

   <para>
    Przesunięcia (offsety) ciągów znaków muszą być liczbami lub numerycznymi ciągami znaków,
    w przeciwnym razie zostanie zgłoszone ostrzeżenie.
   </para>

   <example>
    <!-- TODO Update for PHP 8.0 -->
    <title>Przykłady niepoprawnych offsetów ciągów znaków</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = 'abc';

var_dump($str['1']);
var_dump(isset($str['1']));

var_dump($str['1.0']);
var_dump(isset($str['1.0']));

var_dump($str['x']);
var_dump(isset($str['x']));

var_dump($str['1x']);
var_dump(isset($str['1x']));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
string(1) "b"
bool(true)

Warning: Illegal string offset '1.0' in /tmp/t.php on line 7
string(1) "b"
bool(false)

Warning: Illegal string offset 'x' in /tmp/t.php on line 9
string(1) "a"
bool(false)
string(1) "b"
bool(false)
]]>
    </screen>
   </example>

   <note>
    <para>
     Dostęp do zmiennych innych typów (innych niż tablice czy obiekty
     implementujące odpowiednie interfejsy) przy użyciu <literal>[]</literal> lub
     <literal>{}</literal> zwraca &null; bez zgłaszania błędów.
    </para>
   </note>

   <note>
    <para>
     Dostęp do znaków wewnątrz ciągów znaków można uzyskać
     używając <literal>[]</literal> lub <literal>{}</literal>.
    </para>
   </note>

   <note>
    <para>
     Dostęp do znaków wewnątrz ciągów znaków przy użyciu
     składni <literal>{}</literal> jest przestarzały od PHP 7.4.
     Ta możliwość została usunięta w PHP 8.0.
    </para>
   </note>
  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.string.useful-funcs">
  <title>Przydatne funkcje i operatory</title>

  <para>
   <type>String</type>i mogą być konkatenowane, czyli łączone, za pomocą operatora "." (kropki). Zauważ,
   że operator "+" (dodawania) <emphasis>nie</emphasis> zadziała w ten sposób.
   Zapoznaj się z rozdziałem <link linkend="language.operators.string">Operatory ciągów znaków</link>, aby
   dowiedzieć się więcej.
  </para>

  <para>
   Istnieje wiele przydatnych funkcji do manipulacji ciągami znaków.
  </para>

  <simpara>
   Zobacz <link linkend="ref.strings">sekcję o funkcjach ciągów znaków</link>, aby
   zobaczyć ogólne funkcje oraz <link linkend="ref.pcre">Funkcje wyrażeń regularnych
   kompatybilnych z Perl</link> dla zaawansowanych operacji typu znajdź &amp; zamień.
  </simpara>

  <simpara>
   Istnieją też <link linkend="ref.url">funkcje dla stringów URL</link> oraz
   funkcje do szyfrowania/odszyfrowywania ciągów znaków
   (<link linkend="ref.sodium">Sodium</link> i
   <link linkend="ref.hash">Hash</link>).
  </simpara>

  <simpara>
   W końcu, zobacz też <link linkend="ref.ctype">funkcje typu
   znaku</link>.
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.string.casting">
  <title>Konwersja na ciąg znaków</title>

  <para>
   Wartość może być skonwertowana na typ <type>string</type> przy użyciu
   rzutowania <literal>(string)</literal> lub funkcji <function>strval</function>.
   Konwersja na ciąg znaków jest wykonywana automatycznie w zakresie
   wyrażenia, które potrzebuje typu <type>string</type>. Dzieje się to gdy używane są
   funkcje <function>echo</function> czy <function>print</function>, lub gdy
   zmienna jest porównywana do ciągu znaków. Sekcje poświęcone
   <link linkend="language.types">Typom</link> i
   <link linkend="language.types.type-juggling">Żonglowaniu typami</link> powinny
   to rozjaśnić. Zapoznaj się też z funkcją <function>settype</function>.
  </para>

  <para>
   Wartość logiczna (typu <type>bool</type>) &true; jest konwertowana na <type>string</type>
   <literal>"1"</literal>. <type>bool</type> &false; jest konwertowana na
   <literal>""</literal> (pusty string). Pozwala to na konwersję w tę
   i z powrotem między wartościami o typach <type>bool</type> i <type>string</type>.
  </para>

  <para>
   Wartość typu <type>int</type> lub <type>float</type> jest konwertowana na
   <type>string</type> reprezentujący daną liczbę tekstowo (zawierającą też
   część wykładniczą dla liczb zmiennoprzecinkowych). Liczby zmiennoprzecinkowe mogą
   być skonwertowane używając notacji wykładniczej (<literal>4.1E+6</literal>).
  </para>

  <note>
   <para>
    Od PHP 8.0.0 separatorem dziesiętnym jest zawsze
    kropka ("<literal>.</literal>"). Przed PHP 8.0.0
    znak separatora dziesiętnego był zdefiniowany zgodnie z ustawieniami regionalnymi skryptu (kategoria
    LC_NUMERIC). Patrz funkcja <function>setlocale</function>.
   </para>
  </note>

  <para>
   Tablice są zawsze konwertowane na ciąg znaków
   <literal>"Array"</literal>; z tego powodu <function>echo</function> ani
   <function>print</function> nie mogą same w sobie pokazać zawartości
   tablicy. Aby wyświetlić pojedynczy element tablicy, użyj konstrukcji jak np.
   <literal>echo $arr['foo']</literal>. Spójrz poniżej, aby zobaczyć porady dla wyświetlania całej
   zawartości.
  </para>

  <para>
   Aby móc skonwertować obiekty na <type>string</type>, musi być
   użyta magiczna metoda <link linkend="language.oop5.magic">__toString</link>.
  </para>

  <para>
   Zasoby (typ <type>resource</type>) są zawsze konwertowane na <type>string</type> o
   strukturze <literal>"Resource id #1"</literal>, gdzie <literal>1</literal>
   to numer zasobu przypisany do niego przez PHP w
   trakcie wykonywania. Mimo iż nie powinno się polegać na dokładnej strukturze
   tego ciągu znaków i może się ona zmienić, to będzie on zawsze unikalny dla danego zasobu
   w trakcie życia wykonywanego skryptu (np. zapytania HTTP lub procesu
   konsolowego) i nie będzie on użyty ponownie dla innych zasobów. Aby pobrać typ zasobu, użyj
   funkcji <function>get_resource_type</function>.
  </para>

  <para>
   &null; jest zawsze konwertowane na pusty ciąg znaków.
  </para>

  <para>
   Jak powiedziano wyżej bezpośrednia konwersja tablic,
   obiektów ani zasobów nie
   dostarcza żadnych przydatnych informacji o wartości stojącej za tym typem. Zobacz
   funkcje <function>print_r</function> i <function>var_dump</function>, aby
   poznać bardziej skuteczne sposoby inspekcji zawartości tych typów.
  </para>

  <para>
   Większość wartości w PHP może być skonwertowana na <type>string</type> w celu permanentnego
   ich zachowania. Ten proces nazywany jest serializacją i wykonuje go
   funkcja <function>serialize</function>.
  </para>

 </sect2>

 <sect2 xml:id="language.types.string.details">

  <title>Szczegóły typu string</title>

  <para>
   Typ <type>string</type> w PHP jest zaimplementowany jako tablica bajtów oraz
   liczba oznaczająca długość buforu. Nie przechowuje on informacji o tym, jak
   te bajty są tłumaczone na znaki, pozostawiając to zadanie programiście.
   Nie ma ograniczeń wartości, z których może być złożony ciąg znaków, w
   szczególności bajty z wartością <literal>0</literal> ("bajty NUL") są dozwolone
   w dowolnym miejscu ciągu znaków (choć kilka funkcji opisanych jest w tym podręczniku jako
   takie, które są "bezpieczne binarnie" mogą przekazać obsługę ciągów do bibliotek, które
   ignorują dane po bajcie NUL).
  </para>
  <para>
   Ta natura typu string wyjaśnia dlaczego w PHP nie istnieje osobny typ "bajt" - tę
   rolę pełnią ciągi znaków. Funkcje, które nie zwracają danych tekstowych, na
   przykład dowolne dane odczytane z gniazda sieciowego, wciąż zwrócą
   typ string.
  </para>
  <para>
   Biorąc pod uwagę, że PHP nie wymusza określonego kodowania dla stringów, ktoś
   może zastanawiać się, jak kodowane są niektóre znaki. Na przykład, czy string
   <literal>"á"</literal> to będzie <literal>"\xE1"</literal> (ISO-8859-1),
   <literal>"\xC3\xA1"</literal> (UTF-8, wariant C),
   <literal>"\x61\xCC\x81"</literal> (UTF-8, wariant D), czy któraś z innych możliwych
   reprezentacji? Odpowiedź brzmi: ciąg znaków będzie zakodowany w taki sposób, w
   jaki jest zakodowany w pliku skryptu. Tak więc jeśli skrypt jest napisany w
   ISO-8859-1, to ciąg znaków będzie zakodowany w ISO-8859-1 i tak dalej. Nie
   jest to jednak prawdą, jeśli włączona jest obsługa Zend Multibyte; w tym wypadku skrypt
   może być zapisany w dowolnym kodowaniu (które jest wprost określone lub
   wykryte), a potem będzie przekonwertowany do określonego kodowania wewnętrznego, które jest potem
   kodowaniem używanym dla stringów.
   Zwróć uwagę, że istnieją pewne ograniczenia kodowania skryptu (bądź też
   kodowania wewnętrznego, jeśli włączone jest Zend Multibyte) - oznacza to prawie
   zawsze, że kodowanie powinno być kompatybilnym nadzbiorem ASCII, takim jak
   UTF-8 lub ISO-8859-1. Zauważ jednak, że te kodowania zależne od stanu, gdzie
   te same wartości bajtów mogą być użyte w przesunięciach wyjściowych i nie-wyjściowych,
   mogą być problematyczne.
  </para>
  <para>
   Oczywiście aby były użyteczne, funkcje które operują na tekście muszą
   czynić pewne założenia na temat kodowania ciągów znaków. Niestety, w tej
   kwestii istnieje wiele różnic pomiędzy funkcjami PHP:
  </para>
  <itemizedlist>
   <listitem>
    <simpara>
     Niektóre funkcje zakładają, że ciąg znaków jest zakodowany w jakimś (dowolnym) kodowaniu
     jedno-bajtowym, ale nie muszą one interpretować tych bajtów jako konkretne
     znaki. Tak jest w wypadku na przykład <function>substr</function>,
     <function>strpos</function>, <function>strlen</function> czy
     <function>strcmp</function>. O tych funkcjach można też myśleć tak,
     że operują one na buforach pamięci, to znaczy działają na bajtach i przesunięciach
     bajtów.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Do innych funkcji przekazuje się kodowanie ciągu znaków, prawdopodobnie przyjmują
     one też domyślne kodowanie, jeśli ta informacja nie została podana. Tak działa np.
     <function>htmlentities</function> i większość
     funkcji z rozszerzenia <link linkend="book.mbstring">mbstring</link>.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Inne wykorzystają obecne ustawienia regionalne (patrz <function>setlocale</function>), ale
     działają bajt po bajcie.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     W końcu, niektóre mogą też zakładać, że ciąg znaków używa konkretnego kodowania,
     najczęściej UTF-8. Tak dzieje się w wypadku większości funkcji z
     rozszerzeń <link linkend="book.intl">intl</link> oraz
     <link linkend="book.pcre">PCRE</link>
     (w tym ostatnim przypadku, tylko gdy użyty został modyfikator <literal>u</literal>).
    </simpara>
   </listitem>
  </itemizedlist>

  <para>
   Ostatecznie oznacza to, że pisanie poprawnych programów używających Unikodu zależy
   od ostrożnego unikania funkcji, które nie będą działać i które prawdopodobnie
   uszkodzą dane, a zamiast tego używainu funkcji, które będą się zachowywały poprawnie,
   zazwyczaj z rozszerzeń <link linkend="book.intl">intl</link> oraz
   <link linkend="book.mbstring">mbstring</link>.
   Jednakże użycie funkcji obsługujących kodowanie Unikodu to dopiero
   początek. Niezależnie od tego, jakie funkcje dostarcza język, kluczowe jest
   rozumienie specyfikacji Unikodu. Przykładowo program, który zakłada, że istnieją
   tylko duże i małe litery, czyni złe założenie.
  </para>
 </sect2>
</sect1><!-- end string -->

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
